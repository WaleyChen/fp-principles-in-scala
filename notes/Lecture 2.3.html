<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 3.3.0 (300201)"/><meta name="created" content="2012-11-16 04:56:53 +0000"/><meta name="source-url" content="http://www.quora.com/What-is-currying"/><meta name="updated" content="2012-11-16 05:16:58 +0000"/><title>Lecture 2.3</title></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
Currying
<div><br/></div><div>Functions Returning Functions</div><div>def sum(f: Int => Int): (Int, Int) => Int = {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def sumF(a: Int, b: Int): Int = </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (a > b) 0 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else f(a) + sumF(a + 1, b) </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sumF </div><div>}</div><div><br/></div><div>def sumInt = sum(x => x)</div><div><br/></div><div>sumInt(1, 2)</div><div><br/></div><div>sum(cub) (1, 10)</div><div><br/></div><div>Multiple Parameter Lists</div><div>def sum(f: Int -> Int)(a: Int, b: Int): Int =&nbsp;&nbsp;</div><div><br/></div><div><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px; line-height: 17.91666603088379px;">Currying means taking a function that takes multiple arguments and turning it into a chain of functions each taking one argument and returning the next function, until the last returns the result</span></div><div><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px; line-height: 17.91666603088379px;"><br/></span></div><div><span style="color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px; line-height: 17.91666603088379px;">def product(f: Int => Int)(a: Int, b: Int): Int =</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a > b) 1 </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else f(a) * product(f)(a+1, b) </div><div>product(x => x * x)(3, 4)</div><div><br/></div><div>def fact(n: Int) = product(x => x)(1, n)</div><div>fact(5)</div><div><br/></div><div>def mapReduce(f: Int => Int, combine: (Int, Int) => Int, zero: Int)(a: Int, b: Int): Int =</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(a > b) zerp </div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else combine(f(a), mapReduce(f, combine, zero)(a + 1, b)) </div><div><br/></div><div>product = mapReduce(f, (x, y) => product x * y, 1)(a, b)</div></body></html>